var browserify = require('browserify');
var path = require('path');
var _ = require('lodash');
var Rx = require('rx');
var fs = require('fs');
var mkpath = require('mkpath');

/*
 * manifest.json
 * https://github.com/michaelp983/manifest.json
 *
 * Copyright (c) 2013 Michael Brady Paulson
 * Licensed under the MIT license.
 */
module.exports = function(grunt) {
    'use strict';

    function mkPath(path) {
        return Rx.Observable.create(function(observer) {
            mkpath(path, function() {
                observer.onNext();
                observer.onCompleted();
            });
        });
    }

    function getDir(manifestPath) {
        var split = manifestPath.split('/');
        return path.join(split.slice(0, split.length - 1).join('/'));
    }

    /**
     * Writes a file with the path provided
     */
    function fsWrite(file, src) {
        var dir = getDir(file);
        var fsWriteObs = Rx.Observable.create(function(observer) {
            fs.writeFile(file, src, function(err) {
                if (err) {
                    observer.onError(err);
                } else {
                    observer.onNext();
                    observer.onCompleted();
                }
            });
        });

        return mkPath(dir)
            .selectMany(fsWriteObs);
    }
    /**
     * Builds the manifest operation.
     * @param {{
     *     debug: Boolean
     * }} options
     * @param {String} file
     * @returns {Q.promise}
     */
    function buildManfiest(options, file) {
        var manifest = defaultManifest(grunt.file.readJSON(file));
        var manDir = getDir(file);
        var src = path.join(manDir, manifest.src);

        console.log(src);
        return Rx.Observable.create(function(observer) {
            var b = browserify()
                .add(src);

            // Adds the externals
            var requires = manifest.requires;
            var externals = manifest.externals;
            var externalFolders = manifest.externalFolders;

            // Requires and externals files
            for (var i = 0; i < requires.length; i++) {
                var index = requires[i].path.indexOf('/') >= 0;
                b.require(
                    index ? path.join(manDir, requires[i].path) : requires[i].path, 
                    {expose: requires[i].name}
                );
            }

            // External folders, external all
            for (var i = 0; i < externalFolders.length; i++) {
                externals.concat(grunt.file.expand(externalFolders[i]));
            }

            // Individual externals
            for (var i = 0; i < externals.length; i++) {
                var index = externals[i].indexOf('/') >= 0;
                b.external(index ? path.join(manDir, externals[i]) : externals[i]);
            }

            b.bundle(options, function(err, src) {
                if (err) {
                    observer.onError();
                } else {
                    observer.onNext([src, manifest.bundle]);
                    observer.onCompleted();
                }
            });
        });
    }

    function buildManifestFromFileArray(fileArr) {
        return Rx.Observable.fromArray(fileArr);
    }

    /**
     * the default required manifest.
     * @param  {{}} manifest
     * @return {{}}
     */
    function defaultManifest(manifest) {
        return _.assign({
            requires: [],
            externals: [],
            externalFolders: [],
            bundle: 'bundle.js'
        }, manifest);
    }

    // The actual grunt tasks.
    grunt.registerMultiTask('manifest_json', 'All your modules are belong to me.', function(target) {

        var options = this.options({
            dist: './dist/',
            files: [],
            manifestFile: 'manifest.json',
            debug: true
        });

        if (typeof(options.files) === 'string') {
            options.files = [options.files];
        } else if (typeof(options.files) === 'undefined') {
            options.files = [];
        }

        // if all is specified then it will use the cwd and look for
        // all of the manifest files.
        if (options.all) {
            var pattern = process.cwd();

            pattern = path.join(pattern, './**/' + options.manifestFile);
            options.files = grunt.file.expand(pattern);
        }

        // Go through each manifest file and builds the bundles.  Also
        // it will relative path all the manifests going into the manifest.json
        // build.
        var self = this;
        var async = self.async();
        var pojo = {};
        var build = Rx.Observable.fromArray(options.files)
            .select(function(filePattern) {
                return grunt.file.expand(filePattern);
            })
            .selectMany(buildManifestFromFileArray)
            .selectMany(function(file) {
                return buildManfiest(options, file);
            })
            .select(function(srcAndBundle) {
                var src = srcAndBundle[0];
                var bundle = path.join(options.dist, srcAndBundle[1]);

                return [bundle, src];
            })
            .selectMany(function(sAndB) {
                var file = sAndB[0];
                var src = sAndB[1];

                return fsWrite(file, src);
            });

        build.subscribe(function() {
            console.log('PWNED');
        }, function(err) {
            console.log(err);
        });

        // grunt.util.async.forEachSeries(options.files, function (filePattern, next) {
        //     var file = grunt.file.expand(filePattern);

        //     var promises = [];
        //     _.each(file, function(f) {
        //         f = path.relative('./', f);
        //         promises.push(manifestBuild(options, f));
        //     });

        //     q.all(promises).then(function() {
        //         next();
        //     });
        // }, self.async());
    });
};

